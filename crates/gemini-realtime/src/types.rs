use serde::{Deserialize, Serialize};

// --- Outgoing Messages (Client -> Server) ---

/// Top-level message sent from the client.
#[derive(Serialize, Debug)]
#[serde(rename_all = "camelCase")]
pub enum ClientMessage {
    Setup(BidiGenerateContentSetup),
    ClientContent(BidiGenerateContentClientContent),
    RealtimeInput(BidiGenerateContentRealtimeInput),
}

/// The initial message to configure the session.
#[derive(Serialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct BidiGenerateContentSetup {
    pub model: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub system_instruction: Option<Content>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub generation_config: Option<GenerationConfig>,
}

/// Configuration for content generation.
#[derive(Serialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct GenerationConfig {
    pub response_modalities: Vec<ResponseModality>,
}

#[derive(Serialize, Debug)]
#[serde(rename_all = "UPPERCASE")]
pub enum ResponseModality {
    Text,
    Audio,
}

/// A message to send text to the model to elicit a spoken response.
#[derive(Serialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct BidiGenerateContentClientContent {
    pub turns: Vec<Content>,
    pub turn_complete: bool,
}

/// A message containing real-time audio data.
#[derive(Serialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct BidiGenerateContentRealtimeInput {
    pub audio: Blob,
}

/// Represents a single piece of content, like text or an image.
#[derive(Serialize, Debug)]
pub struct Content {
    pub role: String,
    pub parts: Vec<Part>,
}

/// A part of a multi-part message.
#[derive(Serialize, Debug)]
pub struct Part {
    pub text: String,
}

/// A blob of binary data, like audio.
#[derive(Serialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct Blob {
    pub mime_type: String,
    pub data: String, // Base64 encoded
}

// --- Incoming Messages (Server -> Client) ---

/// A top-level message received from the server.
#[derive(Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct ServerMessage {
    pub setup_complete: Option<serde_json::Value>,
    pub server_content: Option<LiveServerContent>,
}

/// Content generated by the model.
#[derive(Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct LiveServerContent {
    pub model_turn: Option<ServerContentTurn>,
    pub input_transcription: Option<ServerTranscription>,
    pub turn_complete: Option<bool>,
}

/// A turn in the conversation from the model.
#[derive(Deserialize, Debug, Clone)]
pub struct ServerContentTurn {
    pub parts: Vec<ServerPart>,
}

/// A part of a server message, which can be text or audio.
#[derive(Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct ServerPart {
    pub text: Option<String>,
    pub inline_data: Option<ServerBlob>,
}

/// A blob of binary data from the server.
#[derive(Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct ServerBlob {
    pub mime_type: String,
    pub data: String, // Base64 encoded
}

/// Transcription of user audio.
#[derive(Deserialize, Debug, Clone)]
pub struct ServerTranscription {
    pub text: String,
}
